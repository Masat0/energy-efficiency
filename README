1. Устанавливаем slurm
2. Настраиваем slurm
либо с помощью конфигуратора https://slurm.schedmd.com/configurator.html либо правим файл 
/etc/slurm/slurm.conf

На какие настройки обратить особое внимание, когда применяем cset на двуядерном проце эти настройки уже не работают

Epilog=путь до файла-скрипта, который переключает частоту по завершению выполнения задания
SchedulerType=sched/builtin
SelectType=select/cons_res
SelectTypeParameters=CR_Core
#что включено логирование и время в миллисекундах
JobAcctGatherFrequency=30
JobAcctGatherType=jobacct_gather/linux
LogTimeFormat=iso8601_ms
SlurmctldDebug=5
SlurmctldLogFile=/var/log/slurm-llnl/slurmctld.log
SlurmdDebug=3
SlurmdLogFile=/var/log/slurm-llnl/slurmd.log

правильно указать такие параметры как Sockets, CPUs, CoresPerSocket, ThreadsPerCore

* после изменений файла конфигурации надо перезапустить слюрм

  sudo systemctl restart slurmctld

3. устанавливаем stress-ng

  sudo apt install stress-ng

4. устанавливем cset

  sudo apt install cpuset

5. для проверки, что запускаем на тех ядрах что нужно, можно поставить htop (понятная графика по нагрузке)

6. устанавливаем, если нужно cpupower и проверяем с помощью команды

  cpupower frequency-info

какие политики нам доступны (нужна userspace) и какие частоты процессора нам доступны (указан диапазон в hardware limits: 1.20 GHz - 2.60 GHz)
тут же пробуем поменять частоту с помощью команды

  sudo cpupower frequency-set -g userspace -d 2.6GHz -u 2.6GHz

подставляя границы и проверяя командой cpupower frequency-info

7. Выделяем ядра процессора в пользование только задачам слюрма. Тут надо еще все проверять.

  sudo cset shield --cpu 1-2

переносим запущенные процессы на другие ядра

  cset shield --kthread on

смотрим какие наборы созданы

  sudo cset set --list

по умолчанию работаем с набором user (он жестко указан в скрипте), но можно заморочиться с созданием именованного набора


8. далее выполняем калибровку, предварительно указав правильные лимиты частот процессора: правим строку for f in 1.2 2.6; в файле calibr_slurm.sh
Если нам доступны (и нужны) для экспериментов более двух ядер, то правим строку for n in $(seq 1 2); заменяя 2 на нужное число ядер

Перед калибровкой необходимо очистить файл с логами, т.к. потом мы будем из него с помощью скрипта вытягивать данные и нужно чтобы он до начала эксперимента был чистым (без информации о ранее выполненных задачах)

Очистку файла можно сделать командой 
  
  sudo truncate -s 0 /var/log/slurm-llnl/slurmctld.log

Или запустить скрипт, который удаляет еще и ранее созданный выходной файл с данными

  sudo sh prepare.sh
Калибровку запускаем командой

  sudo sh calibr_slurm.sh <количество итераций для заданной частоты и работы>

После выполнения всех задач, парсим лог файл /var/log/slurm-llnl/slurmctld.log (путь к лог файлу для ubuntu). Этот путь указан в скрипте, при необходимости заменить

  sudo python parse_slurmctld_log.py

Получаем выходной файл out.csv

9. Перед запуском эксперимента, нужно исправить значения вероятностей в файле slurm_epilog_random.sh (вероятность переключить частоту при завершении задачи pd, единица соответствует числу 32767) и в файле run_task_random.sh вероятность pa

Очистить лог слюрма 

  sudo truncate -s 0 /var/log/slurm-llnl/slurmctld.log

Подготовить входной файл, формат которого следующий (можно проверить что все работает на файле testdata)
первый столбец - размер работы (количество операций для stress-ng)
второй столбец - время между приходом заявок, пауза (секунды, дробная часть отделяется обязательно точкой)
третий столбец - сколько узлов занимает заявка
столбцы разделены пробелом, строка должна заканчиваться LF, не CRLF. Команда для удаления виндовой каретки
  
! ВАЖНО: пауза работает только с секундами

  tr -d '\r' < source-file > dest-file

Запустить эксперимент

  sudo bash run_task_random.sh <имя входного файла>

После завершения вычислений, распарсить лог-файл слюрма командой

  sudo python parse_slurmctld_log.py

! Если задач в эксперименте достаточно много, то в ходе эксперимента часть лога будет заархивирована в файлы slurmctld.log.N.gz где N - номер архива. В таком случае нужно этот файл разархивировать и объединить с текущим логом, а потом уже к этому файлу применить парсер

Питоновский dictionary не предполагает сортировку ключей, поэтому я переставлял столбцы вручную.